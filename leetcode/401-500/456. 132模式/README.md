# 456. 132模式

> 难度：中等

## 说明

给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足:i < j < k 和 nums[i] < nums[k] < nums[j] 。

如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。

## 进阶

很容易想到时间复杂度为 O(n^2) 的解决方案，你可以设计一个时间复杂度为 O(n logn) 或 O(n) 的解决方案吗？

## 示例

示例 1:

> **输入：** nums = [1,2,3,4]
> 
> **输出：** false
> 
> **解释：** 序列中不存在 132 模式的子序列。

示例 2:

> **输入：** nums = [3,1,4,2]
> 
> **输出：** true
> 
> **解释：** 序列中有 1 个 132 模式的子序列: [1, 4, 2] 。

示例 3:

> **输入：** nums = [-1,3,2,0]
> 
> **输出：** true
> 
> **解释：** 序列中有 3 个 132 模式的的子序列:[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。


## 提示

> n == nums.length
> 
> 1 <= n <= 104
> 
> -109 <= nums[i] <= 109

## 思路

首先需要想到应当通过枚举 i, j, k 来进行计算。

通过 numi < numk < numj 可以推得 numi < numk 且 numi < numj，所以从右向左遍历 i 效果更佳：

使用 `单调栈` 存储右侧遍历数组的信息，使用额外变量存储目前最大的 `numk` 取值。

具体流程如下：

1. 初始化栈，栈中有数组的最后一个元素（`提示` 输入数组的长度最少为1）；
2. 从倒数第二个开始向前遍历（`num`）：
   1. 当 `numk` 不为空时，如果 `num` 比 `numk` 小，则找到了 `132模式`；
   2. 从 `单调栈` 中弹出所有比 `num` 小的元素，并更新 `numk` 使其保持最大值；
   3. 如果 `栈顶` 元素现在与 `num` 不等，则将 `num` 入栈。
      1. 此处是为方便编码，逻辑上应当是弹出 `栈顶` 元素再将 `num` 入栈，即单调栈弹出的元素与 `num` 相等时不更新 `numk`。

因为所有的 `numk` 都由 `单调栈` 弹出，所以能够保证对于任何 `numk` ，都一定存在某个合法的 `numj` 在栈中。

所以只需要查找尽可能大的 `numk` 即可，此时更可能找到合法的 `numi` 。
