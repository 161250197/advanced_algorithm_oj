# 1049. 最后一块石头的重量 II

> 难度：中等

## 说明

有一堆石头，用整数数组 `stones` 表示。其中`stones[i]` 表示第 `i` 块石头的重量。

每一回合，从中选出 **任意两块石头** ，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

* 如果 `x == y`，那么两块石头都会被完全粉碎；
* 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

最后， **最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。

## 示例

示例 1:

> **输入：** stones = [2,7,4,1,8,1]
> 
> **输出：** 1
> 
> **解释：**
> 
> 组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
> 
> 组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
> 
> 组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
> 
> 组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。

示例 2:

> **输入：** stones = [31,26,33,21,40]
> 
> **输出：** 5

示例 3:

> **输入：** stones = [1,2]
> 
> **输出：** 1

## 提示

> 1 <= stones.length <= 30
> 
> 1 <= stones[i] <= 100

## 思路

粉碎石头的过程相当于消减了两次某个石头的重量，因为结果不可能为负数，所以结果等价于所有石头的总重量 `stoneWeightSum`，减去被粉碎石头的总重量的两倍，由此可以知道可能的最优解为 `Math.floor(stoneWeightSum / 2)`。

由此该问题可以转化为背包问题，使用动态规划解决，构建二维布尔数组，`matrix[i][j]` 表示从第1个到第i个石头是否可以构建总重量为 `j`。

第0行表示不选择石头，固只有 `matrix[0][0]` 为 `true`。

动态转移方程根据上一行的结果以及当前石头是否比目标的总重量重进行转移：

* 若 `matrix[i - 1][j]` 为 `true` ，则 `matrix[i][j]` 也为 `true` 。
* 否则比较当前石头重量与目标的总重量的差异：
    * 若与目标的总重量相等，则 `matrix[i][j] = true`；
    * 若比目标的总重量轻，则 `matrix[i][j] = matrix[i - 1][j - stoneWeight]`;
    * 否则，`matrix[i][j]` 为 `false`。

实际可行的最优解即为 `matrix[stoneCount]` 行的最大值。
